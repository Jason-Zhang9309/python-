python面试准备

Python语言特性

已掌握	1 Python的函数参数传递

		类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。
		当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了
		函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉
		函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改
		
		2 Python中的元类(metaclass)
		
		
已掌握	3 @staticmethod和@classmethod
		
		Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法
		静态方法和类方法不需要创建实例即可调用，静态方法和单独定义的方法一样，只是托管于某个类中方便代码维护，类方法可以定义在父类中，这样可以在不创建父类实例的情况下获得父类的属性
		
		\		实例方法	类方法			静态方法
		a = A()	a.foo(x)	a.class_foo(x)	a.static_foo(x)
		A		不可用		A.class_foo(x)	A.static_foo(x)
		
		
已掌握	4 类变量和实例变量
		
		类变量：是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。
		实例变量：实例化之后，每个实例单独拥有的变量
		
		
已掌握	5 Python自省
		自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
		
		
已掌握	6 字典推导式
		import random
		randomdict = {i : random.randint(10, 100) for i in range(1, 5)}
		print(randomdict)
		>>> 
		{1: 46, 2: 67, 3: 17, 4: 62}
		name = ["张三", "李四", "王五", "李六"]  # 保存名字列表
		sign = ["白羊座", "双鱼座", "狮子座", "处女座"]  #保存星座列表
		dict1 = {i : j for i, j in zip(name, sign)}    # 字典推导式
		print(dict1)
		>>> 
		{'张三': '白羊座', '李四': '双鱼座', '王五': '狮子座', '李六': '处女座'}
		zip()函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。zip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。
		
		
		7 Python中单下划线和双下划线
		
		8 字符串格式化:\x和.format
		9 迭代器和生成器
		10 *args and **kwargs
		11 面向切面编程AOP和装饰器
		12 鸭子类型
		13 Python中重载
		14 新式类和旧式类
		15 __new__和init的区别
		16 单例模式
		1 使用__new__方法
		2 共享属性
		3 装饰器版本
		4 import方法
		17 Python中的作用域
		18 GIL线程全局锁
		19 协程
		20 闭包
		21 lambda函数
		22 Python函数式编程
已掌握	23 Python里的拷贝
		
		引用和copy(),deepcopy()的区别

			import copy
			a = [1, 2, 3, 4, ['a', 'b']]  #原始对象

			b = a  #赋值，传对象的引用
			c = copy.copy(a)  #对象拷贝，浅拷贝
			d = copy.deepcopy(a)  #对象拷贝，深拷贝

			a.append(5)  #修改对象a
			a[4].append('c')  #修改对象a中的['a', 'b']数组对象

			print 'a = ', a
			print 'b = ', b
			print 'c = ', c
			print 'd = ', d

			输出结果：
			a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
			b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
			c =  [1, 2, 3, 4, ['a', 'b', 'c']]
			d =  [1, 2, 3, 4, ['a', 'b']]
			
			
已掌握	24 Python垃圾回收机制
		Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。
		
			1 引用计数
				PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。

				优点:

				简单
				实时性
				缺点:

				维护引用计数消耗资源
				循环引用
				
			2 标记-清除机制
				
				基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。
				
			3 分代技术
				分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。

				Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

				举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。
				
				
		25 Python的List
		
已掌握	26 Python的is
		
		is是对比地址,==是对比值
		
		27 read,readline和readlines
		
		read 读取整个文件
		readline 读取下一行,使用生成器方法
		readlines 读取整个文件到一个迭代器以供我们遍历
		
		
		28 Python2和3的区别
		29 super init
		
		
已掌握	30 range and xrange
		xrange 和 range 这两个基本上都是在循环的时候用。xrange内存性能更好。
		xrange 用法与 range 完全相同，所不同的是生成的不是一个list对象，而是一个生成器。
		由上面的示例可以知道：要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。

		python3 中取消了 range 函数，而把 xrange 函数重命名为 range，所以现在直接用 range 函数即可
		
操作系统
		1 select,poll和epoll
		2 调度算法
		3 死锁
		4 程序编译与链接
		1 预处理
		2 编译
		3 汇编
		4 链接
		5 静态链接和动态链接
		6 虚拟内存技术
		7 分页和分段
		分页与分段的主要区别
		8 页面置换算法
		9 边沿触发和水平触发
		
数据库
		1 事务
		数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行
		
		
		2 数据库索引
		http://blog.codinglabs.org/articles/theory-of-mysql-index.html
		
		3 Redis原理
			Redis是什么？
				1、是一个完全开源免费的key-value内存数据库
				2、通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets
				
			Redis数据库
				通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作
				
				速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万
				持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof)
				自动操作：对不同数据类型的操作都是自动的，很安全
				快速的主--从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。
				Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。
				
			Redis缺点
				是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
				Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。
			
			
		4 乐观锁和悲观锁
			悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作

			乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性
			
			
		5 MVCC
			全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。
			
			
			MySQL的innodb引擎是如何实现MVCC的？
				innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（事务的隔离级别请看这篇文章）下，具体各种数据库操作的实现：

				select：满足以下两个条件innodb会返回该行数据：
				该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。
				该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。
				insert：将新插入的行的创建版本号设置为当前系统的版本号。
				delete：将要删除的行的删除版本号设置为当前系统的版本号。
				update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。
				其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。

				​	由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。

				通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。
			
			
		6 MyISAM和InnoDB
			MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。

			InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，

网络
		1 三次握手
		2 四次挥手
		3 ARP协议
		地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。
		4 urllib和urllib2的区别
		5 Post和Get
		6 Cookie和Session
		7 apache和nginx的区别
		
		
		8 网站用户密码保存
		
			明文保存
			明文hash后保存,如md5
			MD5+Salt方式,这个salt可以随机
			知乎使用了Bcrypy(好像)加密
			
			
		9 HTTP和HTTPS
		10 XSRF和XSS
		11 幂等 Idempotence
		12 RESTful架构(SOAP,RPC)
		13 SOAP
		14 RPC
		
		
		15 CGI和WSGI
		
			CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。 CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。

			WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。
			
			
		16 中间人攻击
		
			中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。
			
		17 c10k问题
		
			所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。
			每一个用户都必须与服务器保持TCP连接才能进行实时的数据交互。Facebook这样的网站同一时间的并发TCP连接可能会过亿。
			解决这一问题，主要思路有两个：一个是对于每个连接处理分配一个独立的进程/线程；另一个思路是用同一进程/线程来同时处理若干连接。
			https://my.oschina.net/xianggao/blog/664275
			
			
		18 socket
			Socket=Ip address+ TCP/UDP + port
			Socket是应用层与协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的协议族隐藏在接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
		
		
		19 浏览器缓存
		
		20 HTTP1.0和HTTP1.1
		
		
		21 Ajax
		
		AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。

*NIX
		unix进程间通信方式(IPC)

数据结构
		1 红黑树

编程题
		1 台阶问题/斐波那契
		
			一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
			思路分析：
			设跳上n级台阶的方法数为 f(n)
			当有n级台阶时，最后一次可以有两种选择：跳一级或跳两级，跳一级时，前面n-1级台阶有f(n-1)种跳法，跳两级时，前面n-2级台阶有f(n-2)种跳法，所以，f(n)=f(n-1)+f(n-2) (n>2), f(1)=1 f(2)=2，这是一个类似斐波那契数列的数列
			
			fib = lambda n: n if n <= 2 else fib(n - 1) + fib(n - 2)
			
			def memo(func):
				cache = {}
				def wrap(*args):
					if args not in cache:
						cache[args] = func(*args)
					return cache[args]
				return wrap


			@memo
			def fib(i):
				if i < 2:
					return 1
				return fib(i-1) + fib(i-2)


		2 变态台阶问题
		一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
		
		fib = lambda n: n if n < 2 else 2 * fib(n - 1))
		
		分析思路：
		设跳上n级台阶的方法数为 f(n)
		当有n级台阶时，最后一次可以有1到n共n种选择：跳一级或跳两级，跳一级时，前面n-1级台阶有f(n-1)种跳法，跳两级时，前面n-2级台阶有f(n-2)种跳法，以此类推，所以，f(n)=f(n-1)+f(n-2)+...+f(1) (n>2), f(1)=1 f(2)=2，f(0)=0,f(n-1)=f(n-2)+f(n-3)+...+f(1),所以f(n)=2*f（n-1）
		
		
		3 矩形覆盖
		
		f = lambda n: n if n <= 2 else f(n - 1) + f(n - 2)
		与台阶问题类似，一个小矩形横着放就是一次上一级，两个小矩形竖着放就是一次上两级
		

		4 杨氏矩阵查找
		5 去除列表中的重复元素
		6 链表成对调换
		7 创建字典的方法
			1 直接创建
			2 工厂方法
			3 fromkeys()方法
		8 合并两个有序列表
		9 交叉链表求交点
		10 二分查找
		11 快排
		12 找零问题
		13 广度遍历和深度遍历二叉树
		17 前中后序遍历
		18 求最大树深
		19 求两棵树是否相同
		20 前序中序求后序
		21 单链表逆置
		22 两个字符串是否是变位词
		23 动态规划问题